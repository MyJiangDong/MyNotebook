#### 作用

是对已有的类额外添加函数和属性并且不需要修改类源码也不需要创建子类

#### 使用场景

当某个三方库的功能无法满足现有业务时需要新增功能时。最简单的做法就是**直接对库源码修改**，但是这样违反了开放封闭原则：对[源码](https://so.csdn.net/so/search?q=源码&spm=1001.2101.3001.7020)**修改**。

更合理的方案是依靠**扩展**。[Kotlin](https://so.csdn.net/so/search?q=Kotlin&spm=1001.2101.3001.7020)的扩展函数很显然能够优雅的解决这种问题

#### 原理

通过解析他的反编译字节码，可以看到该函数会变成一个**静态不可重写**的方法，并且**receiver变成了第一个参数**。扩展函数里的的this就是receiver参数

#### 扩展函数在哪里可以被使用

- 不定义在类中，也就是类外部
  可以看到上面反编译后的扩展函数就是这种类型，被static，public，final修饰的方法会有这个特征：在**同一个包中是可以共享这个扩展函数**的也就是可以调用到这个扩展函数。其他包里面如果也想使用这个函数就可以import这个包中的这个函数即可。
- 定义在类中，也就是类内部
  这时候诡异的事情出现了，**扩展函数无法被调用**。接下来看下对应的扩展函数反编译后的字节码：
- 总结下，如果没有定义在类中那么该函数就是静态的大家都可以调用。如果定义在类中那么就默认属于该类和子类的普通函数，所以只有在该类和子类中使用。上面只是说了调用的地方，实际上调用还是需要使用receiver进行调用。

#### 函数优先级

有没有想过这样一种情况：就是这个类扩展的函数名之前在这个类中就已经存在了，那么调用这个方法时，会调用扩展函数还是之前类中定义好的方法。

答案是：之前类中定义的方法、
因此：**成员方法优先级高于扩展函数**

#### 扩展函数时需要注意

* 如果该扩展函数定义在类内部就是顶级函数/成员函数，不能被覆盖；（因为是基于运行时类型）
* 我们无法访问其接收器的非公共属性；（本质是将其变为方法的第一个参数）
* 扩展接收器总是被静态调度。（和重载一样）
* 也是最重要的一点，不要滥用扩展特性，思考好合适的接受者receivers，不要什么都往context上堆；参数简化要考虑是否有副作用
  

